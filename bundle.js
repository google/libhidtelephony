/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/lib/hid.ts":
/*!************************!*\
  !*** ./src/lib/hid.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getOnOffControlType = exports.OnOffControlType = exports.usageToString = exports.getUsagePage = exports.getUsageId = exports.LedUsage = exports.TelephonyUsage = exports.UsagePage = void 0;\n/** Selected USB.org defined UsagePages IDs. */\nvar UsagePage;\n(function (UsagePage) {\n    UsagePage[UsagePage[\"LED\"] = 8] = \"LED\";\n    UsagePage[UsagePage[\"TELEPHONY\"] = 11] = \"TELEPHONY\";\n})(UsagePage = exports.UsagePage || (exports.UsagePage = {}));\n/** Selected USB.org defined TelephonyUsage IDs. */\nvar TelephonyUsage;\n(function (TelephonyUsage) {\n    TelephonyUsage[TelephonyUsage[\"PHONE\"] = 1] = \"PHONE\";\n    TelephonyUsage[TelephonyUsage[\"PROGRAMMABLE_BUTTON\"] = 7] = \"PROGRAMMABLE_BUTTON\";\n    TelephonyUsage[TelephonyUsage[\"HOOK_SWITCH\"] = 32] = \"HOOK_SWITCH\";\n    TelephonyUsage[TelephonyUsage[\"FLASH\"] = 33] = \"FLASH\";\n    TelephonyUsage[TelephonyUsage[\"FEATURE\"] = 34] = \"FEATURE\";\n    TelephonyUsage[TelephonyUsage[\"REDIAL\"] = 36] = \"REDIAL\";\n    TelephonyUsage[TelephonyUsage[\"DROP\"] = 38] = \"DROP\";\n    TelephonyUsage[TelephonyUsage[\"PHONE_MUTE\"] = 47] = \"PHONE_MUTE\";\n    TelephonyUsage[TelephonyUsage[\"ANSWER_ON_OFF\"] = 116] = \"ANSWER_ON_OFF\";\n    TelephonyUsage[TelephonyUsage[\"LINE_BUSY_TONE\"] = 151] = \"LINE_BUSY_TONE\";\n    TelephonyUsage[TelephonyUsage[\"RINGER\"] = 158] = \"RINGER\";\n})(TelephonyUsage = exports.TelephonyUsage || (exports.TelephonyUsage = {}));\n/** Selected USB.org defined LedUsage IDs. */\nvar LedUsage;\n(function (LedUsage) {\n    LedUsage[LedUsage[\"MUTE\"] = 9] = \"MUTE\";\n    LedUsage[LedUsage[\"OFF_HOOK\"] = 23] = \"OFF_HOOK\";\n    LedUsage[LedUsage[\"RING\"] = 24] = \"RING\";\n    LedUsage[LedUsage[\"HOLD\"] = 32] = \"HOLD\";\n    LedUsage[LedUsage[\"MICROPHONE\"] = 33] = \"MICROPHONE\";\n})(LedUsage = exports.LedUsage || (exports.LedUsage = {}));\n/** Get the usage id from usage field. */\nfunction getUsageId(usage) {\n    return usage & 0xffff;\n}\nexports.getUsageId = getUsageId;\n/** Get the usage page id from usage field. */\nfunction getUsagePage(usage) {\n    return usage >>> 16;\n}\nexports.getUsagePage = getUsagePage;\nfunction usagePageToString(usagePage) {\n    var _a;\n    const str = (_a = UsagePage[usagePage]) !== null && _a !== void 0 ? _a : 'UNKNOWN';\n    return `${str}(0x${usagePage.toString(16).padStart(2, '0')})`;\n}\n/**\n * Cast usage field to human readable string. This only handle usages we care.\n */\nfunction usageToString(usage) {\n    var _a, _b;\n    const usagePage = getUsagePage(usage);\n    const usageId = getUsageId(usage);\n    let str;\n    switch (usagePage) {\n        case UsagePage.LED:\n            str = (_a = LedUsage[usageId]) !== null && _a !== void 0 ? _a : 'UNKNOWN';\n            break;\n        case UsagePage.TELEPHONY:\n            str = (_b = TelephonyUsage[usageId]) !== null && _b !== void 0 ? _b : 'UNKNOWN';\n            break;\n        default:\n            str = 'UNKNOWN';\n            break;\n    }\n    return `${usagePageToString(usagePage)}.${str}(0x${usageId\n        .toString(16)\n        .padStart(2, '0')})`;\n}\nexports.usageToString = usageToString;\nvar OnOffControlType;\n(function (OnOffControlType) {\n    OnOffControlType[OnOffControlType[\"Undefined\"] = 0] = \"Undefined\";\n    OnOffControlType[OnOffControlType[\"OnOffButtons\"] = 1] = \"OnOffButtons\";\n    OnOffControlType[OnOffControlType[\"ToggleButton\"] = 2] = \"ToggleButton\";\n    OnOffControlType[OnOffControlType[\"ToggleSwitch\"] = 3] = \"ToggleSwitch\";\n})(OnOffControlType = exports.OnOffControlType || (exports.OnOffControlType = {}));\nfunction getOnOffControlType(item) {\n    if (item.isAbsolute === undefined ||\n        item.hasPreferredState === undefined ||\n        item.logicalMinimum === undefined ||\n        item.logicalMaximum === undefined) {\n        return OnOffControlType.Undefined;\n    }\n    if (!item.isAbsolute &&\n        !item.hasPreferredState &&\n        item.logicalMinimum === -1 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.OnOffButtons;\n    }\n    if (!item.isAbsolute &&\n        item.hasPreferredState &&\n        item.logicalMinimum === 0 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.ToggleButton;\n    }\n    if (item.isAbsolute &&\n        !item.hasPreferredState &&\n        item.logicalMinimum === 0 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.ToggleSwitch;\n    }\n    return OnOffControlType.Undefined;\n}\nexports.getOnOffControlType = getOnOffControlType;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/hid.ts?");

/***/ }),

/***/ "./src/lib/hid_telephony.ts":
/*!**********************************!*\
  !*** ./src/lib/hid_telephony.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TelephonyDeviceManager = void 0;\nconst hid_1 = __webpack_require__(/*! ./hid */ \"./src/lib/hid.ts\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/lib/logger.ts\");\nconst TELEPHONY_DEVICE_FILTERS = {\n    usagePage: hid_1.UsagePage.TELEPHONY,\n};\n/** Following signals are sent from the device to the host. */\nconst INPUT_USAGES = [\n    hid_1.TelephonyUsage.HOOK_SWITCH,\n    hid_1.TelephonyUsage.PHONE_MUTE,\n];\nconst isTelephonyInputUsage = (x) => INPUT_USAGES.includes(x);\n/** Following signals are sent from the host to the device. */\nconst OUTPUT_USAGES = [\n    hid_1.LedUsage.OFF_HOOK,\n    hid_1.LedUsage.RING,\n    hid_1.LedUsage.MUTE,\n    hid_1.TelephonyUsage.RINGER,\n    // LedUsage.HOLD,\n    // LedUsage.MICROPHONE,\n];\nconst isTelephonyOutputUsage = (x) => OUTPUT_USAGES.includes(x);\n/**\n * A manager for managing single device supporting telephony usage through\n * WebHID.\n */\nclass TelephonyDeviceManager {\n    constructor(device, verbose) {\n        this.device = device;\n        this.logger = new logger_1.Logger(verbose);\n        this.logger.debug(device);\n        this.inputEventInfos = INPUT_USAGES.reduce((record, usage) => {\n            return { ...record, [usage]: undefined };\n        }, {});\n        this.inputEventObserverCallbacks = INPUT_USAGES.reduce((record, usage) => {\n            return { ...record, [usage]: [] };\n        }, {});\n        this.outputEventGenerators = OUTPUT_USAGES.reduce((templates, usage) => {\n            return { ...templates, [usage]: undefined };\n        }, {});\n        this.parseDeviceDescriptors();\n        this.open();\n        this.device.addEventListener('inputreport', e => this.onInputReport(e));\n    }\n    /**\n     * Create a TelephonyDeviceManager instance for a selected telephony device.\n     * Returns null if none is selected.\n     */\n    static async create(verbose = logger_1.Level.INFO) {\n        const hid = window.navigator.hid;\n        const hidDevices = await hid.requestDevice({\n            filters: [TELEPHONY_DEVICE_FILTERS],\n        });\n        if (hidDevices.length === 0)\n            return null;\n        return new TelephonyDeviceManager(hidDevices[0], verbose);\n    }\n    onInputReport(event) {\n        this.logger.debug(`Receive an event with reportId ${event.reportId} and data: ${new Uint8Array(event.data.buffer)}`);\n        for (const usage of INPUT_USAGES) {\n            const eventInfo = this.inputEventInfos[usage];\n            if (eventInfo === undefined || event.reportId !== eventInfo.reportId) {\n                continue;\n            }\n            const byteIndex = Math.trunc(eventInfo.offset / 8);\n            const bitPosition = eventInfo.offset % 8;\n            const isSet = (event.data.getUint8(byteIndex) & (0x01 << bitPosition)) !== 0;\n            for (const callback of this.inputEventObserverCallbacks[usage]) {\n                callback(isSet, eventInfo.controlType);\n            }\n        }\n    }\n    async open() {\n        if (!this.device.opened) {\n            this.logger.info(`Open device :${this.device.productName}`);\n            await this.device.open();\n        }\n    }\n    async close() {\n        if (!this.device.opened) {\n            await this.device.close();\n        }\n    }\n    /* Parse USB descriptors for reading/writing reports from/to the device. */\n    async parseDeviceDescriptors() {\n        if (this.device.collections === undefined) {\n            this.logger.error('Undefined device collection');\n            throw new Error('Undefined device collection');\n        }\n        const telephonyCollection = this.device.collections.find(collection => collection.usagePage === hid_1.UsagePage.TELEPHONY);\n        if (telephonyCollection === undefined) {\n            this.logger.error('No telephony collection');\n            throw new Error('No telephony collection');\n        }\n        if (telephonyCollection.inputReports) {\n            this.parseInputReport(telephonyCollection.inputReports);\n        }\n        if (telephonyCollection.outputReports) {\n            this.parseOutputReport(telephonyCollection.outputReports);\n        }\n    }\n    parseInputReport(inputReports) {\n        for (const report of inputReports) {\n            let offset = 0;\n            if (report.items === undefined || report.reportId === undefined) {\n                continue;\n            }\n            for (const item of report.items) {\n                if (item.usages === undefined ||\n                    item.reportSize === undefined ||\n                    item.reportCount === undefined ||\n                    item.isAbsolute === undefined) {\n                    continue;\n                }\n                for (const [i, usage] of item.usages.entries()) {\n                    if (hid_1.getUsagePage(usage) === hid_1.UsagePage.TELEPHONY) {\n                        const usageId = hid_1.getUsageId(usage);\n                        if (isTelephonyInputUsage(usageId)) {\n                            this.inputEventInfos[usageId] = {\n                                reportId: report.reportId,\n                                offset: offset + i * item.reportSize,\n                                controlType: hid_1.getOnOffControlType(item),\n                            };\n                            this.logger.debug(`InputReport: ${hid_1.usageToString(usage)} `, `reportId: ${report.reportId} `, `offset: ${offset + i * item.reportSize} `, `isAbsolute: ${item.isAbsolute}`);\n                        }\n                    }\n                }\n                offset += item.reportCount * item.reportSize;\n            }\n        }\n    }\n    parseOutputReport(outputReports) {\n        for (const report of outputReports) {\n            if (report.items === undefined || report.reportId === undefined) {\n                continue;\n            }\n            let offset = 0;\n            let outUsageOffsets = [];\n            for (const item of report.items) {\n                if (item.usages === undefined ||\n                    item.reportSize === undefined ||\n                    item.reportCount === undefined) {\n                    outUsageOffsets = [];\n                    break;\n                }\n                for (const [i, usage] of item.usages.entries()) {\n                    const usagePage = hid_1.getUsagePage(usage);\n                    if (usagePage === hid_1.UsagePage.TELEPHONY ||\n                        usagePage === hid_1.UsagePage.LED) {\n                        const usageId = hid_1.getUsageId(usage);\n                        if (isTelephonyOutputUsage(usageId)) {\n                            outUsageOffsets.push([usageId, offset + i * item.reportSize]);\n                            this.logger.debug(`OutputReport: ${hid_1.usageToString(usage)} reportId:${report.reportId} offset: ${offset + i * item.reportSize}`);\n                        }\n                    }\n                }\n                offset += item.reportCount * item.reportSize;\n            }\n            const length = offset;\n            for (const [usageId, offset] of outUsageOffsets) {\n                this.outputEventGenerators[usageId] = (val) => {\n                    const reportData = new Uint8Array(length / 8);\n                    if (offset >= 0 && val) {\n                        const byteIndex = Math.trunc(offset / 8);\n                        const bitPosition = offset % 8;\n                        reportData[byteIndex] = 1 << bitPosition;\n                    }\n                    return { reportId: report.reportId, data: reportData };\n                };\n            }\n        }\n    }\n    getControlType(usage) {\n        var _a;\n        if (this.supportInput(usage)) {\n            return (_a = this.inputEventInfos[usage]) === null || _a === void 0 ? void 0 : _a.controlType;\n        }\n        return undefined;\n    }\n    supportInput(usage) {\n        return this.inputEventInfos[usage] !== undefined;\n    }\n    supportOutput(usage) {\n        return this.outputEventGenerators[usage] !== undefined;\n    }\n    subscribe(usage, callback) {\n        this.inputEventObserverCallbacks[usage].push(callback);\n    }\n    /* Subscribe the Input event. */\n    unsubscribe(usage, callback) {\n        const callbackIndex = this.inputEventObserverCallbacks[usage].indexOf(callback);\n        if (callbackIndex === -1) {\n            this.logger.error('Nonexistent callback.');\n            return;\n        }\n        this.inputEventObserverCallbacks[usage].splice(callbackIndex, 1);\n    }\n    /* Send a Ring event to the device. */\n    sendRing(val) {\n        if (!this.device.opened) {\n            return;\n        }\n        const generator = this.outputEventGenerators[hid_1.LedUsage.RING];\n        if (generator !== undefined) {\n            const report = generator(val);\n            this.device.sendReport(report.reportId, report.data);\n        }\n    }\n    /* Trigger event(s) with both off-hook and mute state to the device. */\n    sendOffHookMute(offHook, mute) {\n        var _a;\n        if (!this.device.opened) {\n            return;\n        }\n        const offHookGenerator = this.outputEventGenerators[hid_1.LedUsage.OFF_HOOK];\n        const muteGenerator = this.outputEventGenerators[hid_1.LedUsage.MUTE];\n        let report;\n        if (offHookGenerator !== undefined && muteGenerator !== undefined) {\n            const offHookReport = offHookGenerator(offHook);\n            const muteReport = muteGenerator(mute);\n            if (offHookReport.reportId !== muteReport.reportId) {\n                this.device.sendReport(offHookReport === null || offHookReport === void 0 ? void 0 : offHookReport.reportId, offHookReport.data);\n                this.device.sendReport(muteReport === null || muteReport === void 0 ? void 0 : muteReport.reportId, muteReport.data);\n                return;\n            }\n            report = {\n                reportId: offHookReport.reportId,\n                data: new Uint8Array(offHookReport.data),\n            };\n            for (const [i, data] of muteReport.data.entries()) {\n                report.data[i] = muteReport.data[i] | data;\n            }\n        }\n        else {\n            report = (_a = offHookGenerator === null || offHookGenerator === void 0 ? void 0 : offHookGenerator(offHook)) !== null && _a !== void 0 ? _a : muteGenerator === null || muteGenerator === void 0 ? void 0 : muteGenerator(mute);\n        }\n        if (report) {\n            this.device.sendReport(report.reportId, report.data);\n        }\n    }\n    /**\n     * Send an output event to the device. This function only set single status\n     * in the report and thus may override other status. Should be used only\n     * for debugging or testing purpose.\n     */\n    send(usage, val) {\n        if (!this.device.opened) {\n            return;\n        }\n        const generator = this.outputEventGenerators[usage];\n        if (generator !== undefined) {\n            const report = generator(val);\n            this.device.sendReport(report.reportId, report.data);\n        }\n    }\n}\nexports.TelephonyDeviceManager = TelephonyDeviceManager;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/hid_telephony.ts?");

/***/ }),

/***/ "./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = exports.Level = void 0;\n/** Logger levels */\nvar Level;\n(function (Level) {\n    Level[Level[\"OFF\"] = 0] = \"OFF\";\n    Level[Level[\"INFO\"] = 1] = \"INFO\";\n    Level[Level[\"DEBUG\"] = 2] = \"DEBUG\";\n})(Level = exports.Level || (exports.Level = {}));\n/** Logger class used to log different level of logs */\nclass Logger {\n    constructor(level = Level.INFO) {\n        this.level = level;\n    }\n    info(...logs) {\n        if (this.level < Level.INFO)\n            return;\n        console.log(...logs);\n    }\n    debug(...logs) {\n        if (this.level < Level.DEBUG)\n            return;\n        console.log(...logs);\n    }\n    error(...logs) {\n        if (this.level === Level.OFF)\n            return;\n        console.error(...logs);\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/logger.ts?");

/***/ }),

/***/ "./src/test_app/main.ts":
/*!******************************!*\
  !*** ./src/test_app/main.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst hid_1 = __webpack_require__(/*! ../lib/hid */ \"./src/lib/hid.ts\");\nconst hid_telephony_1 = __webpack_require__(/*! ../lib/hid_telephony */ \"./src/lib/hid_telephony.ts\");\nfunction copyLog() {\n    const logs = Array.from(document.getElementsByClassName('log-content'))\n        .map(log => log.innerText)\n        .join('\\n');\n    if (logs) {\n        navigator.clipboard.writeText(logs);\n    }\n}\nfunction clearLog() {\n    const log = document.getElementById('log');\n    log.innerHTML = '';\n}\nfunction appendLog(msg) {\n    const log = document.getElementById('log');\n    const line = document.createElement('div');\n    const date = document.createElement('span');\n    const content = document.createElement('span');\n    const dateTime = new Date();\n    line.className = 'log-msg';\n    date.className = 'log-date';\n    content.className = 'log-content';\n    date.innerText = `${new Intl.DateTimeFormat('default', {\n        hour12: false,\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric',\n    }).format(dateTime)}  `;\n    content.innerText = msg;\n    line.appendChild(date);\n    line.appendChild(content);\n    log.appendChild(line);\n    line.scrollIntoView();\n}\nfunction oocTypeToString(val) {\n    return val ? hid_1.OnOffControlType[val] : 'undefined';\n}\nfunction booleanToIcon(val) {\n    if (val === undefined)\n        return '❓';\n    return val ? '✅' : '❌';\n}\nfunction reset() {\n    const outputCtrl = document.getElementById('output-controls');\n    outputCtrl.hidden = true;\n    outputCtrl.innerHTML = '<h4>Output Controls</h4>';\n    const testCases = document.getElementById('test-cases');\n    testCases.hidden = true;\n    testCases.innerHTML = '<h4>Test Cases</h4>';\n    clearLog();\n}\nconst timeout = async (ms) => new Promise(res => setTimeout(res, ms));\nlet dialogValReady = false;\nasync function waitUserInput() {\n    while (!dialogValReady)\n        await timeout(100);\n    dialogValReady = false;\n}\nconst dialog = document.getElementById('dialog');\nconst yesBtn = document.getElementById('dialog-yes');\nconst yesCallback = () => {\n    dialog.setAttribute('val', 'true');\n    dialogValReady = true;\n    dialog.hidden = true;\n};\nyesBtn.onclick = yesCallback;\nconst noBtn = document.getElementById('dialog-no');\nconst noCallback = () => {\n    dialog.setAttribute('val', 'false');\n    dialogValReady = true;\n    dialog.hidden = true;\n};\nnoBtn.onclick = noCallback;\nasync function confirmYesNo(msg, hideYes = false) {\n    document.getElementById('dialog-msg').innerText = msg;\n    yesBtn.hidden = hideYes;\n    noBtn.hidden = false;\n    dialog.hidden = false;\n    await waitUserInput();\n    return dialog.getAttribute('val') === 'true';\n}\nfunction verifyInputReport(deviceManager) {\n    const inputReportTable = document.getElementById('input-report');\n    const hookSwitch = inputReportTable.rows[1];\n    hookSwitch.cells[1].innerText = booleanToIcon(deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH));\n    hookSwitch.cells[2].innerText = oocTypeToString(deviceManager.getControlType(hid_1.TelephonyUsage.HOOK_SWITCH));\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH)) {\n        deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, (val, type) => {\n            appendLog(`Received: HookSwitch(${val}) as type ${oocTypeToString(type)}`);\n        });\n    }\n    const phoneMute = inputReportTable.rows[2];\n    phoneMute.cells[1].innerText = booleanToIcon(deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE));\n    phoneMute.cells[2].innerText = oocTypeToString(deviceManager.getControlType(hid_1.TelephonyUsage.PHONE_MUTE));\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE)) {\n        deviceManager.subscribe(hid_1.TelephonyUsage.PHONE_MUTE, (val, type) => {\n            appendLog(`Received: PhoneMute(${val}) as type ${oocTypeToString(type)}`);\n        });\n    }\n    appendLog('Input Event Support:');\n    appendLog(`    Hook-Switch: ${deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH)}`);\n    appendLog(`    Phone-Mute: ${deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE)}`);\n}\nfunction verifyOutputReport(deviceManager) {\n    const outputReportTable = document.getElementById('output-report');\n    outputReportTable.rows[1].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK));\n    outputReportTable.rows[2].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.RING));\n    outputReportTable.rows[3].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.MUTE));\n    const outputCtrl = document.getElementById('output-controls');\n    const controlTable = document.createElement('table');\n    outputCtrl.appendChild(controlTable);\n    function insertControls(deviceManager, title, usage) {\n        const row = controlTable.insertRow();\n        row.innerHTML = `\n        <td>${title}</td>\n        <td>\n          <button>${title}(1)</button>\n          <button>${title}(0)</button>\n        </td>\n      `;\n        for (const val of [1, 0]) {\n            const btn = row.cells[1].children[1 - val];\n            btn.addEventListener('click', () => {\n                deviceManager.send(usage, val === 1);\n                appendLog(`Send a ${title}(${val}) event`);\n            });\n        }\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK)) {\n        insertControls(deviceManager, 'Off-Hook', hid_1.LedUsage.OFF_HOOK);\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.RING)) {\n        insertControls(deviceManager, 'Ring', hid_1.LedUsage.RING);\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.MUTE)) {\n        insertControls(deviceManager, 'Mute', hid_1.LedUsage.MUTE);\n    }\n    if (deviceManager.supportOutput(hid_1.TelephonyUsage.RINGER)) {\n        insertControls(deviceManager, 'Ringer', hid_1.TelephonyUsage.RINGER);\n    }\n    outputCtrl.hidden = false;\n    appendLog('Output Event Support:');\n    appendLog(`    Led.Off-Hook: ${deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK)}`);\n    appendLog(`    Led.Ring: ${deviceManager.supportOutput(hid_1.LedUsage.RING)}`);\n    appendLog(`    Led.Mute: ${deviceManager.supportOutput(hid_1.LedUsage.MUTE)}`);\n    appendLog(`    Telephony.Ringer: ${deviceManager.supportOutput(hid_1.TelephonyUsage.RINGER)}`);\n}\nasync function ringTestCase(deviceManager) {\n    const callStatusIndicator = await confirmYesNo('Ring, step 1 of 3:\\n' +\n        'Does the DUT design an indicator (LED) for Call Status?');\n    appendLog(`With a call status indicator: ${callStatusIndicator}`);\n    if (!callStatusIndicator) {\n        return true;\n    }\n    deviceManager.sendRing(true);\n    if (!(await confirmYesNo('Ring, step 2 of 3:\\n' +\n        '1. The app is triggering an event for the indicator to turn on. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) show an Ringing Call?'))) {\n        return false;\n    }\n    deviceManager.sendRing(false);\n    if (!(await confirmYesNo('Ring, step 3 of 3:\\n' +\n        '1. The app is triggering an event for the indicator to turn off. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) change to No Call?'))) {\n        return false;\n    }\n    return true;\n}\nasync function muteTestCase(deviceManager) {\n    const statusIndicator = await confirmYesNo('Mute, step 1 of 5:\\n' +\n        'Does the DUT design an indicator (LED) for Microphone Mute Status?');\n    appendLog(`With a microphone status indicator: ${statusIndicator}`);\n    if (!statusIndicator) {\n        return true;\n    }\n    deviceManager.sendOffHookMute(false, true);\n    if (!(await confirmYesNo('Mute, step 2 of 5:\\n' +\n        '1. The app is triggering an event for the indicator to turn on. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) show the microphone is mute?'))) {\n        return false;\n    }\n    if (!(await confirmYesNo('Mute, step 3 of 5:\\n' +\n        '1. Please use another tab to a recorder to verify if the microphone is muted.\\n' +\n        '2. Is the DUT microphone muted?'))) {\n        return false;\n    }\n    deviceManager.sendOffHookMute(false, false);\n    if (!(await confirmYesNo('Mute, step 4 of 5:\\n' +\n        '1. The app is triggering an event for the indicator to turn off. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) change to not muted?'))) {\n        return false;\n    }\n    if (!(await confirmYesNo('Mute, step 5 of 5:\\n' +\n        '1. Please use another tab to a recorder to verify if the microphone is un-muted.\\n' +\n        '2. Is the DUT microphone unmuted?'))) {\n        return false;\n    }\n    return true;\n}\nasync function offHookTestCase(deviceManager) {\n    const callStatusIndicator = await confirmYesNo('Off Hook, step 1 of 3:\\n' +\n        'Does the DUT design an indicator (LED) for Call Status?');\n    appendLog(`With a call status indicator: ${callStatusIndicator}`);\n    if (!callStatusIndicator) {\n        appendLog('May skip the test');\n        return true;\n    }\n    deviceManager.sendOffHookMute(true, false);\n    if (!(await confirmYesNo('Off Hook, step 2 of 3:\\n' +\n        '1. The app is triggering an event for the indicator to turn on. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) show an Active Call?'))) {\n        return false;\n    }\n    deviceManager.sendOffHookMute(false, false);\n    if (!(await confirmYesNo('Off Hook, step 3 of 3:\\n' +\n        '1. The app is triggering an event for the indicator to turn off. (Wait for few seconds.)\\n' +\n        '2. Does the indicator (LED) change to No Call?'))) {\n        return false;\n    }\n    return true;\n}\nasync function hookSwitchTestCase(deviceManager) {\n    const controlType = deviceManager.getControlType(hid_1.TelephonyUsage.HOOK_SWITCH);\n    const waitForHookSwitch = (val, type) => {\n        if (type === hid_1.OnOffControlType.ToggleButton && val) {\n            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n            yesCallback();\n        }\n        else if (type === hid_1.OnOffControlType.ToggleSwitch && val) {\n            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n            yesCallback();\n        }\n        else {\n            noCallback();\n        }\n    };\n    appendLog('Test catch:');\n    appendLog('Send Led.OffHook(0)');\n    deviceManager.sendOffHookMute(false, false);\n    appendLog('Send Led.Ring(1)');\n    deviceManager.sendRing(true);\n    deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n    if (!(await confirmYesNo('Hook Switch, Step 1 of 2:\\n' +\n        'Check the status of Hook Switch is True:\\n ' +\n        '1. Press the Hook Switch button and wait.\\n' +\n        '2. In the log, does HookSwitch(true) appear?\\n', true))) {\n        deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n        deviceManager.sendRing(false);\n        deviceManager.sendOffHookMute(false, false);\n        return false;\n    }\n    deviceManager.sendRing(false);\n    appendLog('Test hang up:');\n    appendLog('Send Led.OffHook(1)');\n    deviceManager.sendOffHookMute(true, false);\n    const waitForHangUp = (val, type) => {\n        if (type === hid_1.OnOffControlType.ToggleButton && val) {\n            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n            yesCallback();\n        }\n        else if (type === hid_1.OnOffControlType.ToggleSwitch && !val) {\n            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n            yesCallback();\n        }\n        else {\n            noCallback();\n        }\n    };\n    deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n    if (!(await confirmYesNo('Hook Switch, Step 2 of 2:\\n' +\n        `Check the status of Hook Switch is ${controlType === hid_1.OnOffControlType.ToggleButton}:\\n ` +\n        '1. Press the Hook Switch button and wait.\\n' +\n        `2. In the log, does HookSwitch(${controlType === hid_1.OnOffControlType.ToggleButton}) appear?\\n`, true))) {\n        deviceManager.sendOffHookMute(false, false);\n        deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n        return false;\n    }\n    appendLog('Send Led.OffHook(0)');\n    deviceManager.sendOffHookMute(false, false);\n    return true;\n}\nfunction verifyTestCasesFeasibility(deviceManager) {\n    const outputReportTable = document.getElementById('test-cases');\n    appendLog('Valid For Test Cases:');\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH)) {\n        const hookSwitchBtn = document.createElement('button');\n        hookSwitchBtn.onclick = async () => {\n            appendLog('==== Start Test Case - Hook Switch ====');\n            appendLog(`Test result: ${(await hookSwitchTestCase(deviceManager)) ? 'Pass' : 'Fail'}`);\n        };\n        hookSwitchBtn.innerText = 'Hook Switch';\n        outputReportTable.append(hookSwitchBtn);\n        appendLog('    Hook Switch');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK)) {\n        const offHookBtn = document.createElement('button');\n        offHookBtn.onclick = async () => {\n            appendLog('==== Start Test Case - Off-Hook ====');\n            appendLog(`Test result: ${(await offHookTestCase(deviceManager)) ? 'Pass' : 'Fail'}`);\n        };\n        offHookBtn.innerText = 'Off-Hook';\n        outputReportTable.append(offHookBtn);\n        appendLog('    Off-Hook');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.RING)) {\n        const ringBtn = document.createElement('button');\n        ringBtn.onclick = async () => {\n            appendLog('==== Start Test Case - Ring ====');\n            appendLog(`Test result: ${(await ringTestCase(deviceManager)) ? 'Pass' : 'Fail'}`);\n        };\n        ringBtn.innerText = 'Ring';\n        outputReportTable.append(ringBtn);\n        appendLog('    Ring');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.MUTE)) {\n        const muteBtn = document.createElement('button');\n        muteBtn.onclick = async () => {\n            appendLog('==== Start Test Case - Mute ====');\n            appendLog(`Test result: ${(await muteTestCase(deviceManager)) ? 'Pass' : 'Fail'}`);\n        };\n        muteBtn.innerText = 'Mute';\n        outputReportTable.append(muteBtn);\n        appendLog('    Mute');\n    }\n    outputReportTable.hidden = false;\n}\nasync function main() {\n    document.getElementById('start').onclick = async () => {\n        const deviceManager = await hid_telephony_1.TelephonyDeviceManager.create();\n        if (deviceManager === null) {\n            appendLog('Failed to create the TelephonyDeviceManager');\n            return;\n        }\n        reset();\n        appendLog(`DUT name: ${deviceManager.device.productName}`);\n        verifyInputReport(deviceManager);\n        verifyOutputReport(deviceManager);\n        verifyTestCasesFeasibility(deviceManager);\n    };\n    document.getElementById('clear').onclick = clearLog;\n    document.getElementById('copy').onclick = copyLog;\n}\nmain();\n\n\n//# sourceURL=webpack://libhidtelephony/./src/test_app/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/test_app/main.ts");
/******/ 	
/******/ })()
;