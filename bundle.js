/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/lib/hid.ts":
/*!************************!*\
  !*** ./src/lib/hid.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nexports.__esModule = true;\nexports.getOnOffControlType = exports.OnOffControlType = exports.usageToString = exports.getUsagePage = exports.getUsageId = exports.LedUsage = exports.TelephonyUsage = exports.UsagePage = void 0;\n/** Selected USB.org defined UsagePages IDs. */\nvar UsagePage;\n(function (UsagePage) {\n    UsagePage[UsagePage[\"LED\"] = 8] = \"LED\";\n    UsagePage[UsagePage[\"TELEPHONY\"] = 11] = \"TELEPHONY\";\n})(UsagePage = exports.UsagePage || (exports.UsagePage = {}));\n/** Selected USB.org defined TelephonyUsage IDs. */\nvar TelephonyUsage;\n(function (TelephonyUsage) {\n    TelephonyUsage[TelephonyUsage[\"PHONE\"] = 1] = \"PHONE\";\n    TelephonyUsage[TelephonyUsage[\"PROGRAMMABLE_BUTTON\"] = 7] = \"PROGRAMMABLE_BUTTON\";\n    TelephonyUsage[TelephonyUsage[\"HOOK_SWITCH\"] = 32] = \"HOOK_SWITCH\";\n    TelephonyUsage[TelephonyUsage[\"FLASH\"] = 33] = \"FLASH\";\n    TelephonyUsage[TelephonyUsage[\"FEATURE\"] = 34] = \"FEATURE\";\n    TelephonyUsage[TelephonyUsage[\"REDIAL\"] = 36] = \"REDIAL\";\n    TelephonyUsage[TelephonyUsage[\"DROP\"] = 38] = \"DROP\";\n    TelephonyUsage[TelephonyUsage[\"PHONE_MUTE\"] = 47] = \"PHONE_MUTE\";\n    TelephonyUsage[TelephonyUsage[\"ANSWER_ON_OFF\"] = 116] = \"ANSWER_ON_OFF\";\n    TelephonyUsage[TelephonyUsage[\"LINE_BUSY_TONE\"] = 151] = \"LINE_BUSY_TONE\";\n    TelephonyUsage[TelephonyUsage[\"RINGER\"] = 158] = \"RINGER\";\n})(TelephonyUsage = exports.TelephonyUsage || (exports.TelephonyUsage = {}));\n/** Selected USB.org defined LedUsage IDs. */\nvar LedUsage;\n(function (LedUsage) {\n    LedUsage[LedUsage[\"MUTE\"] = 9] = \"MUTE\";\n    LedUsage[LedUsage[\"OFF_HOOK\"] = 23] = \"OFF_HOOK\";\n    LedUsage[LedUsage[\"RING\"] = 24] = \"RING\";\n    LedUsage[LedUsage[\"HOLD\"] = 32] = \"HOLD\";\n    LedUsage[LedUsage[\"MICROPHONE\"] = 33] = \"MICROPHONE\";\n})(LedUsage = exports.LedUsage || (exports.LedUsage = {}));\n/**\n * Get the usage ID from usage field.\n * @param {number} usage\n * @return {number} usageId\n */\nfunction getUsageId(usage) {\n    return usage & 0xffff;\n}\nexports.getUsageId = getUsageId;\n/**\n * Get the usage page ID from usage field.\n * @param {number} usage\n * @return {number} usagePage\n */\nfunction getUsagePage(usage) {\n    return usage >>> 16;\n}\nexports.getUsagePage = getUsagePage;\n/**\n * Convert the usage page ID to string.\n * @param {number} usagePage\n * @return {string}\n */\nfunction usagePageToString(usagePage) {\n    var _a;\n    var str = (_a = UsagePage[usagePage]) !== null && _a !== void 0 ? _a : 'UNKNOWN';\n    return str + \"(0x\" + usagePage.toString(16).padStart(2, '0') + \")\";\n}\n/**\n * Cast usage field to human readable string. This only handle usages we care.\n * @param {number} usage\n * @return {string}\n */\nfunction usageToString(usage) {\n    var _a, _b;\n    var usagePage = getUsagePage(usage);\n    var usageId = getUsageId(usage);\n    var str;\n    switch (usagePage) {\n        case UsagePage.LED:\n            str = (_a = LedUsage[usageId]) !== null && _a !== void 0 ? _a : 'UNKNOWN';\n            break;\n        case UsagePage.TELEPHONY:\n            str = (_b = TelephonyUsage[usageId]) !== null && _b !== void 0 ? _b : 'UNKNOWN';\n            break;\n        default:\n            str = 'UNKNOWN';\n            break;\n    }\n    return usagePageToString(usagePage) + \".\" + str + \"(0x\" + usageId\n        .toString(16)\n        .padStart(2, '0') + \")\";\n}\nexports.usageToString = usageToString;\nvar OnOffControlType;\n(function (OnOffControlType) {\n    OnOffControlType[OnOffControlType[\"Undefined\"] = 0] = \"Undefined\";\n    OnOffControlType[OnOffControlType[\"OnOffButtons\"] = 1] = \"OnOffButtons\";\n    OnOffControlType[OnOffControlType[\"ToggleButton\"] = 2] = \"ToggleButton\";\n    OnOffControlType[OnOffControlType[\"ToggleSwitch\"] = 3] = \"ToggleSwitch\";\n})(OnOffControlType = exports.OnOffControlType || (exports.OnOffControlType = {}));\n/**\n * Get the type of the on/off control of the given report item.\n * @param {HIDReportItem} item\n * @return {OnOffControlType} type\n */\nfunction getOnOffControlType(item) {\n    if (item.isAbsolute === undefined ||\n        item.hasPreferredState === undefined ||\n        item.logicalMinimum === undefined ||\n        item.logicalMaximum === undefined) {\n        return OnOffControlType.Undefined;\n    }\n    if (!item.isAbsolute &&\n        !item.hasPreferredState &&\n        item.logicalMinimum === -1 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.OnOffButtons;\n    }\n    if (!item.isAbsolute &&\n        item.hasPreferredState &&\n        item.logicalMinimum === 0 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.ToggleButton;\n    }\n    if (item.isAbsolute &&\n        !item.hasPreferredState &&\n        item.logicalMinimum === 0 &&\n        item.logicalMaximum === 1) {\n        return OnOffControlType.ToggleSwitch;\n    }\n    return OnOffControlType.Undefined;\n}\nexports.getOnOffControlType = getOnOffControlType;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/hid.ts?");

/***/ }),

/***/ "./src/lib/hid_telephony.ts":
/*!**********************************!*\
  !*** ./src/lib/hid_telephony.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nexports.__esModule = true;\nexports.TelephonyDeviceManager = void 0;\nvar hid_1 = __webpack_require__(/*! ./hid */ \"./src/lib/hid.ts\");\nvar logger_1 = __webpack_require__(/*! ./logger */ \"./src/lib/logger.ts\");\nvar TELEPHONY_DEVICE_FILTERS = {\n    usagePage: hid_1.UsagePage.TELEPHONY,\n};\n/** Following signals are sent from the device to the host. */\nvar INPUT_USAGES = [\n    hid_1.TelephonyUsage.HOOK_SWITCH,\n    hid_1.TelephonyUsage.PHONE_MUTE,\n];\nvar isTelephonyInputUsage = function (x) {\n    return INPUT_USAGES.includes(x);\n};\n/** Following signals are sent from the host to the device. */\nvar OUTPUT_USAGES = [\n    hid_1.LedUsage.OFF_HOOK,\n    hid_1.LedUsage.RING,\n    hid_1.LedUsage.MUTE,\n    hid_1.TelephonyUsage.RINGER,\n    // LedUsage.HOLD,\n    // LedUsage.MICROPHONE,\n];\nvar isTelephonyOutputUsage = function (x) {\n    return OUTPUT_USAGES.includes(x);\n};\n/**\n * A manager for managing single device supporting telephony usage through\n * WebHID.\n */\nvar TelephonyDeviceManager = /** @class */ (function () {\n    /**\n     * Construct a TelephonyDeviceManager for the given HIDDevice\n     * @param {HIDDevice} device The device to interact with.\n     * @param {Level} verbose The verbose level of the logger.\n     */\n    function TelephonyDeviceManager(device, verbose) {\n        var _this = this;\n        this.device = device;\n        this.logger = new logger_1.Logger(verbose);\n        this.logger.debug(device);\n        this.inputEventInfos = INPUT_USAGES.reduce(function (record, usage) {\n            var _a;\n            return __assign(__assign({}, record), (_a = {}, _a[usage] = undefined, _a));\n        }, {});\n        this.inputEventObserverCallbacks = INPUT_USAGES.reduce(function (record, usage) {\n            var _a;\n            return __assign(__assign({}, record), (_a = {}, _a[usage] = [], _a));\n        }, {});\n        this.outputEventInfos = OUTPUT_USAGES.reduce(function (record, usage) {\n            var _a;\n            return __assign(__assign({}, record), (_a = {}, _a[usage] = undefined, _a));\n        }, {});\n        this.parseDeviceDescriptors();\n        this.open();\n        this.device.addEventListener('inputreport', function (e) {\n            return _this.onInputReport(e);\n        });\n    }\n    /**\n     * Create a TelephonyDeviceManager instance for a selected telephony device.\n     * @param {Level} verbose The verbose level of the logger.\n     * @return {TelephonyDeviceManager} Returns null if none is selected.\n     */\n    TelephonyDeviceManager.create = function (verbose) {\n        if (verbose === void 0) { verbose = logger_1.Level.DEBUG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var hid, hidDevices;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        hid = window.navigator.hid;\n                        return [4 /*yield*/, hid.requestDevice({\n                                filters: [TELEPHONY_DEVICE_FILTERS],\n                            })];\n                    case 1:\n                        hidDevices = _a.sent();\n                        if (hidDevices.length === 0)\n                            return [2 /*return*/, null];\n                        return [2 /*return*/, new TelephonyDeviceManager(hidDevices[0], verbose)];\n                }\n            });\n        });\n    };\n    /**\n     * Callbackto handle the input report from the connected device.\n     * @param {HIDInputReportEvent} event The triggered input event.\n     */\n    TelephonyDeviceManager.prototype.onInputReport = function (event) {\n        var e_1, _a, e_2, _b;\n        this.logger.debug(\"Receive an event with reportId \" + event.reportId + \" and data: \" + new Uint8Array(event.data.buffer));\n        try {\n            for (var INPUT_USAGES_1 = __values(INPUT_USAGES), INPUT_USAGES_1_1 = INPUT_USAGES_1.next(); !INPUT_USAGES_1_1.done; INPUT_USAGES_1_1 = INPUT_USAGES_1.next()) {\n                var usage = INPUT_USAGES_1_1.value;\n                var eventInfo = this.inputEventInfos[usage];\n                if (eventInfo === undefined || event.reportId !== eventInfo.reportId) {\n                    continue;\n                }\n                var byteIndex = Math.trunc(eventInfo.offset / 8);\n                var bitPosition = eventInfo.offset % 8;\n                var isSet = (event.data.getUint8(byteIndex) & (0x01 << bitPosition)) !== 0;\n                try {\n                    for (var _c = (e_2 = void 0, __values(this.inputEventObserverCallbacks[usage])), _d = _c.next(); !_d.done; _d = _c.next()) {\n                        var callback = _d.value;\n                        callback(isSet, eventInfo.controlType);\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_d && !_d.done && (_b = _c[\"return\"])) _b.call(_c);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (INPUT_USAGES_1_1 && !INPUT_USAGES_1_1.done && (_a = INPUT_USAGES_1[\"return\"])) _a.call(INPUT_USAGES_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Open the device.\n     */\n    TelephonyDeviceManager.prototype.open = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this.device.opened) return [3 /*break*/, 2];\n                        this.logger.info(\"Open device :\" + this.device.productName);\n                        return [4 /*yield*/, this.device.open()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Close the device\n     */\n    TelephonyDeviceManager.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this.device.opened) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.device.close()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     *  Parse USB descriptors for reading/writing reports from/to the device.\n     */\n    TelephonyDeviceManager.prototype.parseDeviceDescriptors = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var telephonyCollection;\n            return __generator(this, function (_a) {\n                if (this.device.collections === undefined) {\n                    this.logger.error('Undefined device collection');\n                    throw new Error('Undefined device collection');\n                }\n                telephonyCollection = this.device.collections.find(function (collection) { return collection.usagePage === hid_1.UsagePage.TELEPHONY; });\n                if (telephonyCollection === undefined) {\n                    this.logger.error('No telephony collection');\n                    throw new Error('No telephony collection');\n                }\n                if (telephonyCollection.inputReports) {\n                    this.parseInputReport(telephonyCollection.inputReports);\n                }\n                if (telephonyCollection.outputReports) {\n                    this.parseOutputReport(telephonyCollection.outputReports);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Helper to parse the input report.\n     * @param {HIDReportInfo[]} inputReports The array of input reports.\n     */\n    TelephonyDeviceManager.prototype.parseInputReport = function (inputReports) {\n        var e_3, _a, e_4, _b, e_5, _c;\n        try {\n            for (var inputReports_1 = __values(inputReports), inputReports_1_1 = inputReports_1.next(); !inputReports_1_1.done; inputReports_1_1 = inputReports_1.next()) {\n                var report = inputReports_1_1.value;\n                var offset = 0;\n                if (report.items === undefined || report.reportId === undefined) {\n                    continue;\n                }\n                try {\n                    for (var _d = (e_4 = void 0, __values(report.items)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                        var item = _e.value;\n                        if (item.usages === undefined ||\n                            item.reportSize === undefined ||\n                            item.reportCount === undefined ||\n                            item.isAbsolute === undefined) {\n                            continue;\n                        }\n                        try {\n                            for (var _f = (e_5 = void 0, __values(item.usages.entries())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                var _h = __read(_g.value, 2), i = _h[0], usage = _h[1];\n                                if (hid_1.getUsagePage(usage) === hid_1.UsagePage.TELEPHONY) {\n                                    var usageId = hid_1.getUsageId(usage);\n                                    if (isTelephonyInputUsage(usageId)) {\n                                        this.inputEventInfos[usageId] = {\n                                            reportId: report.reportId,\n                                            offset: offset + i * item.reportSize,\n                                            controlType: hid_1.getOnOffControlType(item),\n                                        };\n                                        this.logger.debug(\"InputReport: \" + hid_1.usageToString(usage) + \" \", \"reportId: \" + report.reportId + \" \", \"offset: \" + (offset + i * item.reportSize) + \" \", \"isAbsolute: \" + item.isAbsolute);\n                                    }\n                                }\n                            }\n                        }\n                        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                        finally {\n                            try {\n                                if (_g && !_g.done && (_c = _f[\"return\"])) _c.call(_f);\n                            }\n                            finally { if (e_5) throw e_5.error; }\n                        }\n                        offset += item.reportCount * item.reportSize;\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (_e && !_e.done && (_b = _d[\"return\"])) _b.call(_d);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (inputReports_1_1 && !inputReports_1_1.done && (_a = inputReports_1[\"return\"])) _a.call(inputReports_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    };\n    /**\n     * Helper to parse the output report.\n     * @param {HIDReportInfo[]} outputReports The array of output reports.\n     */\n    TelephonyDeviceManager.prototype.parseOutputReport = function (outputReports) {\n        var e_6, _a;\n        var _loop_1 = function (report) {\n            var e_7, _b, e_8, _c, e_9, _d;\n            if (report.items === undefined || report.reportId === undefined) {\n                return \"continue\";\n            }\n            var offset = 0;\n            var outUsageOffsets = [];\n            try {\n                for (var _e = (e_7 = void 0, __values(report.items)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var item = _f.value;\n                    if (item.usages === undefined ||\n                        item.reportSize === undefined ||\n                        item.reportCount === undefined) {\n                        outUsageOffsets = [];\n                        break;\n                    }\n                    try {\n                        for (var _g = (e_8 = void 0, __values(item.usages.entries())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                            var _j = __read(_h.value, 2), i = _j[0], usage = _j[1];\n                            var usagePage = hid_1.getUsagePage(usage);\n                            if (usagePage === hid_1.UsagePage.TELEPHONY ||\n                                usagePage === hid_1.UsagePage.LED) {\n                                var usageId = hid_1.getUsageId(usage);\n                                if (isTelephonyOutputUsage(usageId)) {\n                                    outUsageOffsets.push([usageId, offset + i * item.reportSize]);\n                                    this_1.logger.debug(\"OutputReport: \" + hid_1.usageToString(usage) + \" \", \"reportId:\" + report.reportId + \" \", \"offset: \" + (offset + i * item.reportSize));\n                                }\n                            }\n                        }\n                    }\n                    catch (e_8_1) { e_8 = { error: e_8_1 }; }\n                    finally {\n                        try {\n                            if (_h && !_h.done && (_c = _g[\"return\"])) _c.call(_g);\n                        }\n                        finally { if (e_8) throw e_8.error; }\n                    }\n                    offset += item.reportCount * item.reportSize;\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e[\"return\"])) _b.call(_e);\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n            var length_1 = offset;\n            var _loop_2 = function (usageId, offset_1) {\n                this_1.outputEventInfos[usageId] = {\n                    reportId: report.reportId,\n                    state: false,\n                    generator: function () {\n                        var reportData = new Uint8Array(length_1 / 8);\n                        return { reportId: report.reportId, data: reportData };\n                    },\n                    setter: function (val, data) {\n                        if (offset_1 >= 0) {\n                            var byteIndex = Math.trunc(offset_1 / 8);\n                            var bitPosition = offset_1 % 8;\n                            data[byteIndex] |= (val ? 1 : 0) << bitPosition;\n                        }\n                        return data;\n                    },\n                };\n            };\n            try {\n                for (var outUsageOffsets_1 = (e_9 = void 0, __values(outUsageOffsets)), outUsageOffsets_1_1 = outUsageOffsets_1.next(); !outUsageOffsets_1_1.done; outUsageOffsets_1_1 = outUsageOffsets_1.next()) {\n                    var _k = __read(outUsageOffsets_1_1.value, 2), usageId = _k[0], offset_1 = _k[1];\n                    _loop_2(usageId, offset_1);\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (outUsageOffsets_1_1 && !outUsageOffsets_1_1.done && (_d = outUsageOffsets_1[\"return\"])) _d.call(outUsageOffsets_1);\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        };\n        var this_1 = this;\n        try {\n            for (var outputReports_1 = __values(outputReports), outputReports_1_1 = outputReports_1.next(); !outputReports_1_1.done; outputReports_1_1 = outputReports_1.next()) {\n                var report = outputReports_1_1.value;\n                _loop_1(report);\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (outputReports_1_1 && !outputReports_1_1.done && (_a = outputReports_1[\"return\"])) _a.call(outputReports_1);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n    };\n    /**\n     * Get which type the input control is for given input usage.\n     * @param {InputUsage} usage\n     * @return {OnOffControlType|undefined}\n     */\n    TelephonyDeviceManager.prototype.getControlType = function (usage) {\n        var _a;\n        if (this.supportInput(usage)) {\n            return (_a = this.inputEventInfos[usage]) === null || _a === void 0 ? void 0 : _a.controlType;\n        }\n        return undefined;\n    };\n    /**\n     * Get if the input usage is supported by the device.\n     * @param {InputUsage} usage The input usage to query.\n     * @return {boolean}\n     */\n    TelephonyDeviceManager.prototype.supportInput = function (usage) {\n        return this.inputEventInfos[usage] !== undefined;\n    };\n    /**\n     * Get if the output usage is supported by the device.\n     * @param {OutputUsage} usage\n     * @return {boolean}\n     */\n    TelephonyDeviceManager.prototype.supportOutput = function (usage) {\n        return this.outputEventInfos[usage] !== undefined;\n    };\n    /**\n     * Subscribe a callback to the input event with specified usage.\n     * @param {InputUsage} usage\n     * @param {ObserverCallback} callback\n     */\n    TelephonyDeviceManager.prototype.subscribe = function (usage, callback) {\n        this.inputEventObserverCallbacks[usage].push(callback);\n    };\n    /**\n     * Unsubscribe a callback from the input event with specified usage.\n     * @param {InputUsage} usage\n     * @param {ObserverCallback} callback\n     */\n    TelephonyDeviceManager.prototype.unsubscribe = function (usage, callback) {\n        var callbackIndex = this.inputEventObserverCallbacks[usage].indexOf(callback);\n        if (callbackIndex === -1) {\n            this.logger.error('Nonexistent callback.');\n            return;\n        }\n        this.inputEventObserverCallbacks[usage].splice(callbackIndex, 1);\n    };\n    /**\n     * Set the host state of the output usage.\n     * @param {OutputUsage} usage\n     * @param {boolean} val\n     */\n    TelephonyDeviceManager.prototype.setState = function (usage, val) {\n        if (!this.device.opened) {\n            return;\n        }\n        var info = this.outputEventInfos[usage];\n        if (info !== undefined) {\n            info.state = val;\n        }\n        return;\n    };\n    /**\n     * Get the host state of the output usage.\n     * @param {OutputUsage} usage\n     * @return {boolean|undefined} Undefined if not supported.\n     */\n    TelephonyDeviceManager.prototype.getState = function (usage) {\n        var _a, _b;\n        this.logger.debug(\"this.device.opened \" + this.device.opened);\n        if (!this.device.opened) {\n            return undefined;\n        }\n        this.logger.debug(\"GetState \" + ((_a = this.outputEventInfos[usage]) === null || _a === void 0 ? void 0 : _a.state));\n        return (_b = this.outputEventInfos[usage]) === null || _b === void 0 ? void 0 : _b.state;\n    };\n    /**\n     * Send output events to the device.\n     * @param {Map<OutputUsage, boolean>} usages Usages to set.\n     */\n    TelephonyDeviceManager.prototype.send = function (usages) {\n        var e_10, _a;\n        var _this = this;\n        if (!this.device.opened) {\n            return;\n        }\n        var outputReports = [];\n        var _loop_3 = function (usage, val) {\n            this_2.logger.debug(\"usage: \" + usage + \", val: \" + val);\n            var eventInfo = this_2.outputEventInfos[usage];\n            if (eventInfo === undefined) {\n                return \"continue\";\n            }\n            var existingReport = outputReports.find(function (report) { return report.reportId === (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.reportId); });\n            if (existingReport === undefined) {\n                outputReports.push(eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.generator());\n            }\n            eventInfo.state = val;\n        };\n        var this_2 = this;\n        try {\n            for (var usages_1 = __values(usages), usages_1_1 = usages_1.next(); !usages_1_1.done; usages_1_1 = usages_1.next()) {\n                var _b = __read(usages_1_1.value, 2), usage = _b[0], val = _b[1];\n                _loop_3(usage, val);\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (usages_1_1 && !usages_1_1.done && (_a = usages_1[\"return\"])) _a.call(usages_1);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n        outputReports.forEach(function (report) {\n            OUTPUT_USAGES.forEach(function (usage) {\n                var eventInfo = _this.outputEventInfos[usage];\n                if (eventInfo === undefined ||\n                    eventInfo.reportId !== report.reportId ||\n                    !eventInfo.state) {\n                    return;\n                }\n                report.data = eventInfo.setter(eventInfo.state, report.data);\n            });\n            _this.logger.debug(\"Send report with \", \"reportId: \" + report.reportId + \" \", \"data: \" + report.data);\n            _this.device.sendReport(report.reportId, report.data);\n        });\n    };\n    return TelephonyDeviceManager;\n}());\nexports.TelephonyDeviceManager = TelephonyDeviceManager;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/hid_telephony.ts?");

/***/ }),

/***/ "./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nexports.__esModule = true;\nexports.Logger = exports.Level = void 0;\n/** Logger levels */\nvar Level;\n(function (Level) {\n    Level[Level[\"OFF\"] = 0] = \"OFF\";\n    Level[Level[\"ERROR\"] = 1] = \"ERROR\";\n    Level[Level[\"INFO\"] = 2] = \"INFO\";\n    Level[Level[\"DEBUG\"] = 3] = \"DEBUG\";\n})(Level = exports.Level || (exports.Level = {}));\n/** Logger class used to log different level of logs */\nvar Logger = /** @class */ (function () {\n    /**\n     * Constructor logger that only print logs with verbosity\n     * that are higher than the speficied level.\n     * @param {Levle} level\n     */\n    function Logger(level) {\n        if (level === void 0) { level = Level.INFO; }\n        this.level = level;\n    }\n    /**\n     * Print info level logs.\n     * @param {unknown[]} logs\n     */\n    Logger.prototype.info = function () {\n        var logs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            logs[_i] = arguments[_i];\n        }\n        if (this.level < Level.INFO)\n            return;\n        console.log.apply(console, __spreadArray([], __read(logs)));\n    };\n    /**\n     * Print debug level logs.\n     * @param {unknown[]} logs\n     */\n    Logger.prototype.debug = function () {\n        var logs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            logs[_i] = arguments[_i];\n        }\n        if (this.level < Level.DEBUG)\n            return;\n        console.log.apply(console, __spreadArray([], __read(logs)));\n    };\n    /**\n     * Print error level logs.\n     * @param {unknown[]} logs\n     */\n    Logger.prototype.error = function () {\n        var logs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            logs[_i] = arguments[_i];\n        }\n        if (this.level < Level.ERROR)\n            return;\n        console.error.apply(console, __spreadArray([], __read(logs)));\n    };\n    return Logger;\n}());\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://libhidtelephony/./src/lib/logger.ts?");

/***/ }),

/***/ "./src/test_app/main.ts":
/*!******************************!*\
  !*** ./src/test_app/main.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar _a, _b, _c;\nexports.__esModule = true;\nvar hid_1 = __webpack_require__(/*! ../lib/hid */ \"./src/lib/hid.ts\");\nvar hid_telephony_1 = __webpack_require__(/*! ../lib/hid_telephony */ \"./src/lib/hid_telephony.ts\");\nvar refreshTimerId;\n/**\n * Copy log to clipboard.\n */\nfunction copyLog() {\n    var logs = Array.from(document.getElementsByClassName('log-content'))\n        .map(function (log) { return log.innerText; })\n        .join('\\n');\n    if (logs) {\n        navigator.clipboard.writeText(logs);\n    }\n}\n/**\n * Clear the log.\n */\nfunction clearLog() {\n    var log = document.getElementById('log');\n    if (log) {\n        log.innerHTML = '';\n    }\n}\n/**\n * Helper to append messages to log.\n * @param {string} msg\n */\nfunction appendLog(msg) {\n    var log = document.getElementById('log');\n    var line = document.createElement('div');\n    var date = document.createElement('span');\n    var content = document.createElement('span');\n    var dateTime = new Date();\n    line.className = 'log-msg';\n    date.className = 'log-date';\n    content.className = 'log-content';\n    date.innerText = new Intl.DateTimeFormat('default', {\n        hour12: false,\n        hour: 'numeric',\n        minute: 'numeric',\n        second: 'numeric',\n    }).format(dateTime) + \"  \";\n    content.innerText = msg;\n    line.appendChild(date);\n    line.appendChild(content);\n    log.appendChild(line);\n    line.scrollIntoView();\n}\n/**\n * Helper to convert OnOffControlType to string.\n * @param { OnOffControlType | undefined} val\n * @return {string}\n */\nfunction oocTypeToString(val) {\n    return val ? hid_1.OnOffControlType[val] : 'undefined';\n}\n/**\n * Helper to convert boolean to an utf-8 icon.\n * @param { OnOffControlType | undefined} val\n * @return {string}\n */\nfunction booleanToIcon(val) {\n    if (val === undefined)\n        return '❓';\n    return val ? '✅' : '❌';\n}\n/**\n * Reset the app.\n */\nfunction reset() {\n    var _a, _b;\n    var outputCtrl = (_a = document.getElementById('output-controls')) !== null && _a !== void 0 ? _a : undefined;\n    if (outputCtrl !== undefined) {\n        outputCtrl.hidden = true;\n        outputCtrl.innerHTML = '<h4>Output Controls</h4>';\n    }\n    var testCases = (_b = document.getElementById('test-cases')) !== null && _b !== void 0 ? _b : undefined;\n    if (testCases !== undefined) {\n        testCases.hidden = true;\n        testCases.innerHTML = '<h4>Test Cases</h4>';\n    }\n    clearLog();\n}\nvar timeout = function (ms) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {\n    return [2 /*return*/, new Promise(function (res) { return setTimeout(res, ms); })];\n}); }); };\nvar dialogValReady = false;\n/**\n * Helper to wait for user's input event.\n */\nfunction waitUserInput() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!!dialogValReady) return [3 /*break*/, 2];\n                    return [4 /*yield*/, timeout(100)];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2:\n                    dialogValReady = false;\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nvar dialog = (_a = document.getElementById('dialog')) !== null && _a !== void 0 ? _a : undefined;\nvar yesBtn = (_b = document.getElementById('dialog-yes')) !== null && _b !== void 0 ? _b : undefined;\nvar noBtn = (_c = document.getElementById('dialog-no')) !== null && _c !== void 0 ? _c : undefined;\nvar yesCallback = undefined;\nvar noCallback = undefined;\nif (dialog !== undefined && yesBtn !== undefined && noBtn !== undefined) {\n    yesCallback = function () {\n        dialog.setAttribute('val', 'true');\n        dialogValReady = true;\n        dialog.hidden = true;\n    };\n    yesBtn.onclick = yesCallback;\n    noCallback = function () {\n        dialog.setAttribute('val', 'false');\n        dialogValReady = true;\n        dialog.hidden = true;\n    };\n    noBtn.onclick = noCallback;\n}\n/**\n * Helper to show a dialog with yes/no button and hint messages\n * @param {string} msg Message to show on the dialog.\n * @param {boolean} hideYes Whether to hide the yes button.\n * @return {boolean}\n */\nfunction confirmYesNo(msg, hideYes) {\n    if (hideYes === void 0) { hideYes = false; }\n    return __awaiter(this, void 0, void 0, function () {\n        var dialogMsg;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    dialogMsg = document.getElementById('dialog-msg');\n                    if (dialogMsg === undefined ||\n                        yesBtn === undefined ||\n                        noBtn === undefined ||\n                        dialog == undefined) {\n                        return [2 /*return*/, false];\n                    }\n                    dialogMsg.innerText = msg;\n                    yesBtn.hidden = hideYes;\n                    noBtn.hidden = false;\n                    dialog.hidden = false;\n                    return [4 /*yield*/, waitUserInput()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, dialog.getAttribute('val') === 'true'];\n            }\n        });\n    });\n}\n/**\n * Helper to verify and show verification result of the device's input reports.\n * @param {TelephonyDeviceManager} deviceManager\n */\nfunction verifyInputReport(deviceManager) {\n    var inputReportTable = document.getElementById('input-report');\n    var hookSwitchRow = inputReportTable.rows[1];\n    hookSwitchRow.cells[1].innerText = booleanToIcon(deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH));\n    hookSwitchRow.cells[2].innerText = oocTypeToString(deviceManager.getControlType(hid_1.TelephonyUsage.HOOK_SWITCH));\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH)) {\n        deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, function (val, type) {\n            appendLog(\"Received: HookSwitch(\" + val + \") as type \" + oocTypeToString(type));\n        });\n    }\n    var phoneMuteRow = inputReportTable.rows[2];\n    phoneMuteRow.cells[1].innerText = booleanToIcon(deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE));\n    phoneMuteRow.cells[2].innerText = oocTypeToString(deviceManager.getControlType(hid_1.TelephonyUsage.PHONE_MUTE));\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE)) {\n        deviceManager.subscribe(hid_1.TelephonyUsage.PHONE_MUTE, function (val, type) {\n            appendLog(\"Received: PhoneMute(\" + val + \") as type \" + oocTypeToString(type));\n        });\n    }\n    var hookSwitch = deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH);\n    appendLog('Input Event Support:');\n    appendLog(\"    Hook-Switch: \" + hookSwitch);\n    appendLog(\"    Phone-Mute: \" + deviceManager.supportInput(hid_1.TelephonyUsage.PHONE_MUTE));\n}\n/**\n * Helper to verify and show verification result of the device's output reports.\n * @param {TelephonyDeviceManager} deviceManager\n */\nfunction verifyOutputReport(deviceManager) {\n    var outputReportTable = document.\n        getElementById('output-report');\n    outputReportTable.rows[1].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK));\n    outputReportTable.rows[2].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.RING));\n    outputReportTable.rows[3].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.LedUsage.MUTE));\n    outputReportTable.rows[4].cells[1].innerText = booleanToIcon(deviceManager.supportOutput(hid_1.TelephonyUsage.RINGER));\n    outputReportTable.rows[1].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.OFF_HOOK));\n    outputReportTable.rows[2].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.RING));\n    outputReportTable.rows[3].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.MUTE));\n    outputReportTable.rows[4].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.TelephonyUsage.RINGER));\n    var outputCtrl = document\n        .getElementById('output-controls');\n    var controlTable = document.createElement('table');\n    outputCtrl.appendChild(controlTable);\n    /**\n     * Helper to insert controls to trigger output usage events.\n     * @param {TelephonyDeviceManager} deviceManager\n     * @param {string} title\n     * @param {OutputUsage} usage\n     */\n    function insertControls(deviceManager, title, usage) {\n        var e_1, _a;\n        var row = controlTable.insertRow();\n        row.innerHTML = \"\\n        <td>\" + title + \"</td>\\n        <td>\\n          <button>\" + title + \"(1)</button>\\n          <button>\" + title + \"(0)</button>\\n        </td>\\n      \";\n        var _loop_1 = function (val) {\n            var btn = row.cells[1].children[1 - val];\n            btn.addEventListener('click', function () {\n                deviceManager.send(new Map([[usage, val === 1]]));\n                appendLog(\"Send a \" + title + \"(\" + val + \") event\");\n            });\n        };\n        try {\n            for (var _b = __values([1, 0]), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var val = _c.value;\n                _loop_1(val);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK)) {\n        insertControls(deviceManager, 'Off-Hook', hid_1.LedUsage.OFF_HOOK);\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.RING)) {\n        insertControls(deviceManager, 'Ring', hid_1.LedUsage.RING);\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.MUTE)) {\n        insertControls(deviceManager, 'Mute', hid_1.LedUsage.MUTE);\n    }\n    if (deviceManager.supportOutput(hid_1.TelephonyUsage.RINGER)) {\n        insertControls(deviceManager, 'Ringer', hid_1.TelephonyUsage.RINGER);\n    }\n    outputCtrl.hidden = false;\n    appendLog('Output Event Support:');\n    appendLog(\"    Led.Off-Hook: \" + deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK));\n    appendLog(\"    Led.Ring: \" + deviceManager.supportOutput(hid_1.LedUsage.RING));\n    appendLog(\"    Led.Mute: \" + deviceManager.supportOutput(hid_1.LedUsage.MUTE));\n    appendLog(\"    Telephony.Ringer: \" + deviceManager.supportOutput(hid_1.TelephonyUsage.RINGER));\n}\n/**\n * Refresth the state column on output-report table.\n * @param {TelephonyDeviceManager} deviceManager\n */\nfunction refreshState(deviceManager) {\n    return __awaiter(this, void 0, void 0, function () {\n        var outputReportTable;\n        return __generator(this, function (_a) {\n            outputReportTable = document.getElementById('output-report');\n            outputReportTable.rows[1].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.OFF_HOOK));\n            outputReportTable.rows[2].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.RING));\n            outputReportTable.rows[3].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.LedUsage.MUTE));\n            outputReportTable.rows[4].cells[2].innerText = booleanToIcon(deviceManager.getState(hid_1.TelephonyUsage.RINGER));\n            return [2 /*return*/];\n        });\n    });\n}\n/**\n * Test case for LED.Ring indicator.\n * @param {TelephonyDeviceManager} deviceManager\n * @return {boolean}\n */\nfunction ringTestCase(deviceManager) {\n    return __awaiter(this, void 0, void 0, function () {\n        var callStatusIndicator;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, confirmYesNo('Ring, step 1 of 3:\\n' +\n                        'Does the DUT design an indicator (LED) for Call Status?')];\n                case 1:\n                    callStatusIndicator = _a.sent();\n                    appendLog(\"With a call status indicator: \" + callStatusIndicator);\n                    if (!callStatusIndicator) {\n                        return [2 /*return*/, true];\n                    }\n                    deviceManager.send(new Map([[hid_1.LedUsage.RING, true]]));\n                    return [4 /*yield*/, confirmYesNo('Ring, step 2 of 3:\\n' +\n                            '1. The app is triggering an event for the indicator to turn on. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) show an Ringing Call?')];\n                case 2:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    deviceManager.send(new Map([[hid_1.LedUsage.RING, false]]));\n                    return [4 /*yield*/, confirmYesNo('Ring, step 3 of 3:\\n' +\n                            '1. The app is triggering an event for the indicator to turn off. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) change to No Call?')];\n                case 3:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\n/**\n * Test case for LED.Mute indicator.\n * @param {TelephonyDeviceManager} deviceManager\n * @return {boolean}\n */\nfunction muteTestCase(deviceManager) {\n    return __awaiter(this, void 0, void 0, function () {\n        var statusIndicator;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, confirmYesNo('Mute, step 1 of 5:\\n' +\n                        'Does the DUT design an indicator (LED) for Microphone Mute Status?')];\n                case 1:\n                    statusIndicator = _a.sent();\n                    appendLog(\"With a microphone status indicator: \" + statusIndicator);\n                    if (!statusIndicator) {\n                        return [2 /*return*/, true];\n                    }\n                    appendLog('Send Led.OffHook(1) Led.Mute(1)');\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, true],\n                        [hid_1.LedUsage.MUTE, true],\n                    ]));\n                    return [4 /*yield*/, confirmYesNo('Mute, step 2 of 5:\\n' +\n                            '1. The app is triggering an event for the indicator to turn on. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) show the microphone is mute?')];\n                case 2:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, confirmYesNo('Mute, step 3 of 5:\\n' +\n                            '1. Please use another tab to record and verify' +\n                            'if the microphone is muted.\\n' +\n                            '2. Is the DUT microphone muted?')];\n                case 3:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, false],\n                        [hid_1.LedUsage.MUTE, false],\n                    ]));\n                    return [4 /*yield*/, confirmYesNo('Mute, step 4 of 5:\\n' +\n                            '1. The app is triggering an event for the indicator to turn off. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) change to not muted?')];\n                case 4:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, confirmYesNo('Mute, step 5 of 5:\\n' +\n                            '1. Please use another tab to record and verify ' +\n                            'if the microphone is un-muted.\\n' +\n                            '2. Is the DUT microphone unmuted?')];\n                case 5:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\n/**\n * Test case for LED.Off-Hook indicator.\n * @param {TelephonyDeviceManager} deviceManager\n * @return {boolean}\n */\nfunction offHookTestCase(deviceManager) {\n    return __awaiter(this, void 0, void 0, function () {\n        var callStatusIndicator;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, confirmYesNo('Off Hook, step 1 of 3:\\n' +\n                        'Does the DUT design an indicator (LED) for Call Status?')];\n                case 1:\n                    callStatusIndicator = _a.sent();\n                    appendLog(\"With a call status indicator: \" + callStatusIndicator);\n                    if (!callStatusIndicator) {\n                        appendLog('May skip the test');\n                        return [2 /*return*/, true];\n                    }\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, true],\n                        [hid_1.LedUsage.MUTE, false],\n                    ]));\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, true],\n                        [hid_1.LedUsage.MUTE, false],\n                    ]));\n                    return [4 /*yield*/, confirmYesNo('Off Hook, step 2 of 3:\\n' +\n                            '1. The app is triggering an event for the indicator to turn on. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) show an Active Call?')];\n                case 2:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, false],\n                        [hid_1.LedUsage.MUTE, false],\n                    ]));\n                    return [4 /*yield*/, confirmYesNo('Off Hook, step 3 of 3:\\n' +\n                            '1. The app is triggering an event for the indicator to turn off. ' +\n                            '(Wait for few seconds.)\\n' +\n                            '2. Does the indicator (LED) change to No Call?')];\n                case 3:\n                    if (!(_a.sent())) {\n                        return [2 /*return*/, false];\n                    }\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\n/**\n * Test case for TelephonyUsage.HOOK_SWITCH mechanism.\n * @param {TelephonyDeviceManager} deviceManager\n * @return {boolean}\n */\nfunction hookSwitchTestCase(deviceManager) {\n    return __awaiter(this, void 0, void 0, function () {\n        var controlType, waitForHookSwitch, waitForHangUp, isToggle;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    controlType = deviceManager.getControlType(hid_1.TelephonyUsage.HOOK_SWITCH);\n                    waitForHookSwitch = function (val, type) {\n                        if (!val ||\n                            (type !== hid_1.OnOffControlType.ToggleSwitch &&\n                                type !== hid_1.OnOffControlType.ToggleButton)) {\n                            if (noCallback) {\n                                noCallback();\n                            }\n                            return;\n                        }\n                        if (yesCallback) {\n                            yesCallback();\n                        }\n                        deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n                        appendLog('Send Led.OffHook(1) and Led.Ring(0)');\n                        deviceManager.send(new Map([\n                            [hid_1.LedUsage.OFF_HOOK, true],\n                            [hid_1.LedUsage.RING, false],\n                        ]));\n                    };\n                    appendLog('Test catch:');\n                    appendLog('Send Led.Ring(1)');\n                    deviceManager.send(new Map([[hid_1.LedUsage.RING, true]]));\n                    deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n                    return [4 /*yield*/, confirmYesNo('Hook Switch, Step 1 of 2:\\n' +\n                            'Check the status of Hook Switch is True:\\n ' +\n                            '1. Press the Hook Switch button and wait.\\n' +\n                            '2. In the log, does HookSwitch(true) appear?\\n', true)];\n                case 1:\n                    if (!(_a.sent())) {\n                        deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHookSwitch);\n                        deviceManager.send(new Map([[hid_1.LedUsage.RING, false]]));\n                        return [2 /*return*/, false];\n                    }\n                    return [4 /*yield*/, new Promise(function (f) { return setTimeout(f, 1000); })];\n                case 2:\n                    _a.sent();\n                    appendLog('Test hang up:');\n                    waitForHangUp = function (val, type) {\n                        if (type === hid_1.OnOffControlType.ToggleButton && val) {\n                            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n                            yesCallback();\n                        }\n                        else if (type === hid_1.OnOffControlType.ToggleSwitch && !val) {\n                            deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n                            yesCallback();\n                        }\n                        else {\n                            noCallback();\n                        }\n                    };\n                    deviceManager.subscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n                    isToggle = controlType === hid_1.OnOffControlType.ToggleButton;\n                    return [4 /*yield*/, confirmYesNo('Hook Switch, Step 2 of 2:\\n' +\n                            (\"Check the status of Hook Switch is \" + isToggle) +\n                            ((controlType === hid_1.OnOffControlType.ToggleButton) + \":\\n \") +\n                            '1. Press the Hook Switch button and wait.\\n' +\n                            (\"2. In the log, does HookSwitch(\" + isToggle + \") appear?\\n\"), true)];\n                case 3:\n                    if (!(_a.sent())) {\n                        deviceManager.send(new Map([\n                            [hid_1.LedUsage.OFF_HOOK, false],\n                            [hid_1.LedUsage.MUTE, false],\n                        ]));\n                        deviceManager.unsubscribe(hid_1.TelephonyUsage.HOOK_SWITCH, waitForHangUp);\n                        return [2 /*return*/, false];\n                    }\n                    appendLog('Send Led.OffHook(0)');\n                    deviceManager.send(new Map([\n                        [hid_1.LedUsage.OFF_HOOK, false],\n                        [hid_1.LedUsage.MUTE, false],\n                    ]));\n                    return [2 /*return*/, true];\n            }\n        });\n    });\n}\n/**\n * Check for the feasibility of each test cases.\n * @param {TelephonyDeviceManager} deviceManager\n */\nfunction verifyTestCasesFeasibility(deviceManager) {\n    var _this = this;\n    var outputReportTable = document.getElementById('test-cases');\n    appendLog('Valid For Test Cases:');\n    if (deviceManager.supportInput(hid_1.TelephonyUsage.HOOK_SWITCH)) {\n        var hookSwitchBtn = document.createElement('button');\n        hookSwitchBtn.onclick = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        appendLog('==== Start Test Case - Hook Switch ====');\n                        _a = appendLog;\n                        _b = \"Test result: \";\n                        return [4 /*yield*/, hookSwitchTestCase(deviceManager)];\n                    case 1:\n                        _a.apply(void 0, [_b + ((_c.sent()) ?\n                                'Pass' : 'Fail')]);\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        hookSwitchBtn.innerText = 'Hook Switch';\n        outputReportTable.append(hookSwitchBtn);\n        appendLog('    Hook Switch');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.OFF_HOOK)) {\n        var offHookBtn = document.createElement('button');\n        offHookBtn.onclick = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        appendLog('==== Start Test Case - Off-Hook ====');\n                        _a = appendLog;\n                        _b = \"Test result: \";\n                        return [4 /*yield*/, offHookTestCase(deviceManager)];\n                    case 1:\n                        _a.apply(void 0, [_b + ((_c.sent()) ?\n                                'Pass' : 'Fail')]);\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        offHookBtn.innerText = 'Off-Hook';\n        outputReportTable.append(offHookBtn);\n        appendLog('    Off-Hook');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.RING)) {\n        var ringBtn = document.createElement('button');\n        ringBtn.onclick = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        appendLog('==== Start Test Case - Ring ====');\n                        _a = appendLog;\n                        _b = \"Test result: \";\n                        return [4 /*yield*/, ringTestCase(deviceManager)];\n                    case 1:\n                        _a.apply(void 0, [_b + ((_c.sent()) ?\n                                'Pass' : 'Fail')]);\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        ringBtn.innerText = 'Ring';\n        outputReportTable.append(ringBtn);\n        appendLog('    Ring');\n    }\n    if (deviceManager.supportOutput(hid_1.LedUsage.MUTE)) {\n        var muteBtn = document.createElement('button');\n        muteBtn.onclick = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        appendLog('==== Start Test Case - Mute ====');\n                        _a = appendLog;\n                        _b = \"Test result: \";\n                        return [4 /*yield*/, muteTestCase(deviceManager)];\n                    case 1:\n                        _a.apply(void 0, [_b + ((_c.sent()) ?\n                                'Pass' : 'Fail')]);\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        muteBtn.innerText = 'Mute';\n        outputReportTable.append(muteBtn);\n        appendLog('    Mute');\n    }\n    outputReportTable.hidden = false;\n}\n/**\n * Main function\n */\nfunction main() {\n    return __awaiter(this, void 0, void 0, function () {\n        var _this = this;\n        return __generator(this, function (_a) {\n            document.getElementById('start').onclick = function () { return __awaiter(_this, void 0, void 0, function () {\n                var deviceManager;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, hid_telephony_1.TelephonyDeviceManager.create()];\n                        case 1:\n                            deviceManager = _a.sent();\n                            if (deviceManager === null) {\n                                appendLog('Failed to create the TelephonyDeviceManager');\n                                return [2 /*return*/];\n                            }\n                            if (refreshTimerId) {\n                                window.clearInterval(refreshTimerId);\n                            }\n                            refreshTimerId = window.setInterval(refreshState, 1000, deviceManager);\n                            reset();\n                            appendLog(\"DUT name: \" + deviceManager.device.productName);\n                            verifyInputReport(deviceManager);\n                            verifyOutputReport(deviceManager);\n                            verifyTestCasesFeasibility(deviceManager);\n                            return [2 /*return*/];\n                    }\n                });\n            }); };\n            document.getElementById('clear').onclick = clearLog;\n            document.getElementById('copy').onclick = copyLog;\n            return [2 /*return*/];\n        });\n    });\n}\nmain();\n\n\n//# sourceURL=webpack://libhidtelephony/./src/test_app/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/test_app/main.ts");
/******/ 	
/******/ })()
;